import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { GitHubService, GitHubIssue } from '../services/GitHubService';
import { AIService, ProjectRequirements, Task } from '../services/AIService';

export class ProjectManager {
    private currentProject: ProjectRequirements | null = null;
    private projectPath: string;

    constructor(
        private context: vscode.ExtensionContext,
        private githubService: GitHubService,
        private aiService: AIService
    ) {
        this.projectPath = path.join(
            vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '',
            '.taskmaster'
        );
        this.loadProject();
    }

    private async loadProject() {
        const configFile = path.join(this.projectPath, 'project.json');
        if (fs.existsSync(configFile)) {
            try {
                const content = fs.readFileSync(configFile, 'utf8');
                this.currentProject = JSON.parse(content);
            } catch (error) {
                console.error('Failed to load project:', error);
            }
        }
    }

    private async saveProject() {
        if (!this.currentProject) {return;}
        
        if (!fs.existsSync(this.projectPath)) {
            fs.mkdirSync(this.projectPath, { recursive: true });
        }
        
        const configFile = path.join(this.projectPath, 'project.json');
        fs.writeFileSync(configFile, JSON.stringify(this.currentProject, null, 2));
    }

    async createProject(projectIdea: string): Promise<ProjectRequirements | null> {
        const requirements = await this.aiService.generateProjectRequirements(projectIdea);
        if (requirements) {
            this.currentProject = requirements;
            await this.saveProject();
            await this.syncWithGitHub();
        }
        return requirements;
    }

    async updateProject(updates: Partial<ProjectRequirements>) {
        if (this.currentProject) {
            this.currentProject = { ...this.currentProject, ...updates };
            await this.saveProject();
        }
    }

    async addTask(task: Task) {
        if (this.currentProject) {
            this.currentProject.tasks.push(task);
            await this.saveProject();
            
            // Create GitHub issue
            const issue = await this.githubService.createIssue(
                task.title,
                this.formatTaskForGitHub(task),
                [task.priority]
            );
            
            if (issue) {
                vscode.window.showInformationMessage(`Created GitHub issue #${issue.id}`);
            }
        }
    }

    async syncWithGitHub() {
        if (!this.currentProject) {return;}
        
        const issues = await this.githubService.getIssues();
        
        // Create issues for tasks that don't exist
        for (const task of this.currentProject.tasks) {
            const existingIssue = issues.find(i => i.title === task.title);
            if (!existingIssue) {
                await this.githubService.createIssue(
                    task.title,
                    this.formatTaskForGitHub(task),
                    [task.priority, 'task-master']
                );
            }
        }
    }

    private formatTaskForGitHub(task: Task): string {
        return `
## Description
${task.description}

## Priority
${task.priority}

## Estimated Hours
${task.estimatedHours}

## Dependencies
${task.dependencies.map(d => `- ${d}`).join('\n')}

## Acceptance Criteria
${task.acceptanceCriteria.map(ac => `- [ ] ${ac}`).join('\n')}

---
*Generated by GitHub Copilot Task Master*
        `.trim();
    }

    getProject(): ProjectRequirements | null {
        return this.currentProject;
    }

    getTasks(): Task[] {
        return this.currentProject?.tasks || [];
    }

    async refineTask(taskTitle: string): Promise<Task | null> {
        if (!this.currentProject) {return null;}
        
        const task = this.currentProject.tasks.find(t => t.title === taskTitle);
        if (task) {
            const refinedTask = await this.aiService.refineTask(
                task,
                this.currentProject.description
            );
            
            if (refinedTask) {
                const index = this.currentProject.tasks.findIndex(t => t.title === taskTitle);
                this.currentProject.tasks[index] = refinedTask;
                await this.saveProject();
                return refinedTask;
            }
        }
        
        return null;
    }
}
